package io.delta.sharing.server

import zio._
import zio.stream._
import zio.test._
import zio.test.Assertion._
import zio.test.Gen._
import zio.test.ZIOSpecDefault
import zio.internal.stacktracer.SourceLocation
import com.amazonaws.services.devicefarm.model.Test
import java.io.StringWriter
import java.io.PrintWriter

/** A trait for the result produced by an executed command. It supplies methods
  * to update the “model” state and check invariants.
  */
trait CommandResult[State] {
  def update(state: State): State
  def ensure(state: State): TestResult
}

/** A Command for stateful property testing. Parameterized by:
  *   - R: The ZIO environment
  *   - State: Your “model” or actual system state.
  *
  * A command now produces a CommandResult when executed.
  */
trait Command[-R, State] {
  type E
  type Result <: CommandResult[State]

  /** Execute the command (using its internal input) against the system. */
  def execute(): ZIO[R, E, Result]
}

object Command {
  type Aux[R, State, CR <: CommandResult[State]] = Command[R, State] {
    type Result = CR
  }
}

object Stateful {

  /** A generator of collections of up to the specified size, where each
    * collection is generated by repeatedly applying a function to an initial
    * state.
    */
  def unfoldGen[R, S, A](s: S)(
      f: S => Gen[R, Option[(S, A)]]
  )(implicit trace: Trace): Gen[R, (List[A], S)] = {

    def loop(s: S, as: List[A]): Gen[R, (List[A], S)] =
      f(s).flatMap {
        case Some((s, a)) => loop(s, a :: as)
        case None         => Gen.const((as.reverse, s))
      }
    loop(s, Nil)
  }

  // Update the type of Step to hold a CommandResult rather than a plain output.
  case class Step[S](
      executedCommand: CommandResult[S],
      state: S
  )

  // Modified StateWrapper: now holds an Option[Any] for error.
  // A value of None indicates a successful command execution.
  case class StateWrapper[S](state: S, error: Option[Any], remainingSteps: Int)

  /** Given an initial state and a function that returns a generator for a
    * command using the current state, builds a generator of Steps.
    */
  def genActions[R, S](
      state0: => S,
      commands: S => List[Gen[R, Command[R, S]]],
      numSteps: Int = 100
  ): Gen[R, List[Step[S]]] = {
    // Use unfoldGen to thread the state through a sequence of generated steps.
    unfoldGen[R, StateWrapper[S], Step[S]](
      StateWrapper(state0, None, numSteps)
    ) { stateWrapper =>
      // Only continue if no error has occurred and steps remain.
      if (stateWrapper.error.isEmpty && stateWrapper.remainingSteps > 0) {
        for {
          possibleCommands <- Gen.fromZIO(
            ZIO
              .collectAll(commands(stateWrapper.state).map(_.runHead))
              .map(_.filter(_.isDefined))
              .debug(
                s"Test command choices (remaining ${stateWrapper.remainingSteps})"
              )
          )
          cmdOpt <- Gen.elements(possibleCommands: _*)
          _ <- Gen.fromZIO(
            ZIO
              .succeed(cmdOpt)
              .debug(
                s"Test command chosen (remaining ${stateWrapper.remainingSteps})"
              )
          )
          step <- cmdOpt
            .map { cmd =>
              for {
                resultEither <- Gen.fromZIO(
                  cmd
                    .execute()
                    .debug(
                      s"Test command executed (remaining ${stateWrapper.remainingSteps})"
                    )
                    .either
                )
                res <- resultEither match {
                  case Right(result) =>
                    // In the success case, update the state using the command's update method.
                    val next = result.update(stateWrapper.state)
                    Gen.some(
                      Gen.const(
                        StateWrapper(
                          next,
                          None,
                          stateWrapper.remainingSteps - 1
                        ) -> Step(result, next)
                      )
                    )
                  case Left(err) =>
                    // In case of error, update StateWrapper with the error.
                    // We create a dummy CommandResult that does nothing to the state
                    // and whose ensure method immediately fails.
                    val errString = err match {
                      case e: Throwable =>
                        val stringWriter = new StringWriter()
                        val printWriter = new PrintWriter(stringWriter)
                        e.printStackTrace(printWriter)
                        stringWriter.toString
                      case x => x.toString
                    }
                    val dummyResult = new CommandResult[S] {
                      def update(state: S): S = state
                      def ensure(state: S): TestResult =
                        assertTrue(errString == null)
                    }
                    Gen.some(
                      Gen.const(
                        StateWrapper(
                          stateWrapper.state,
                          Some(err),
                          stateWrapper.remainingSteps - 1
                        ) -> Step(dummyResult, stateWrapper.state)
                      )
                    )
                }
              } yield res
            }
            .getOrElse(Gen.none)
        } yield step
      } else Gen.none
    }
  }.map(_._1).noShrink

  def allStepsSuccessful[S](steps: List[Step[S]]): TestResult =
    steps
      .map(s => s.executedCommand.ensure(s.state))
      .foldLeft(assertTrue(true))(_ && _)
}
