package io.delta.sharing.server

import zio._
import zio.stream._
import zio.test._
import zio.test.Assertion._
import zio.test.Gen._
import zio.test.ZIOSpecDefault
import zio.internal.stacktracer.SourceLocation
import com.amazonaws.services.devicefarm.model.Test
import java.io.StringWriter
import java.io.PrintWriter

object StatefulDeterministic {

  /** A Command for stateful property testing under a fully deterministic setup.
    *
    * Parameterized by:
    *   - R: The ZIO environment.
    *   - State: Your “model” or actual system state.
    *
    * Since command execution is fully deterministic, one can predict the new
    * state using the `update` method without having to inspect a separate
    * result.
    */
  trait Command[-R, State] {
    type E

    /** Executes the command against the System Under Test.
      *
      * In a deterministic setting, any state change caused by this command is
      * fully captured by the `update` method.
      */
    def executeAndCheck(state: State): ZIO[R, E, TestResult]

    /** Predicts the new state, given the current state. */
    def update(state: State): State

    /** Checks that the invariants hold given the state after this command. */
  }
  object Command {
    def dummy[R, S]: Command[R, S] = new Command[R, S] {
      type E = Nothing
      def executeAndCheck(state: S): ZIO[R, Nothing, TestResult] =
        ZIO.succeed(assertTrue(true))
      def update(state: S): S = state
      def ensure(state: S): TestResult = assertTrue(true)
    }
  }

  /** A generator of collections of up to the specified size, where each
    * collection is generated by repeatedly applying a function to an initial
    * state.
    */
  def unfoldGen[R, S, A](s: S)(
      f: S => Gen[R, Option[(S, A)]]
  )(implicit trace: Trace): Gen[R, (List[A], S)] = {

    def loop(s: S, as: List[A], steps: Int): Gen[R, (List[A], S)] =
      f(s).flatMap {
        case Some((s, a)) if steps > 0 => loop(s, a :: as, steps - 1)
        case _                      => Gen.const((as.reverse, s))
      }
    Gen.sized(size => loop(s, Nil, size))
  }

  // The Step now records the command (merged with its result) and the updated state.
  case class Step[R, S](
      command: Command[R, S],
      state: S
  )

  // A StateWrapper is used to thread through the current state, error state (if any), and
  // the remaining number of steps.
  case class StateWrapper[S](state: S, error: Option[Any])

  /** Given an initial state and a function that returns a generator for a
    * command built using the current state, this builds a generator of Steps.
    */
  def genActions[R, S](
      state0: => S,
      commands: S => List[Gen[R, Command[R, S]]],
  ): Gen[R, List[Step[R, S]]] = {
    // Use unfoldGen to thread the state through a sequence of generated steps.
    unfoldGen[R, StateWrapper[S], Step[R, S]](
      StateWrapper(state0, None)
    ) { stateWrapper =>
      // Only continue if no error has occurred and steps remain.
      if (stateWrapper.error.isEmpty) {
        for {
          possibleCommands <- Gen.fromZIO(
            ZIO
              .collectAll(commands(stateWrapper.state).map(_.runHead))
              .map(_.filter(_.isDefined))
              .debug(
                s"Test command choices"
              )
          )
          cmdOpt <- Gen.elements(possibleCommands: _*)
          _ <- Gen.fromZIO(
            ZIO
              .succeed(cmdOpt)
              .debug(
                s"Test command chosen"
              )
          )
          step <- cmdOpt
            .map { cmd =>
              for {
                res <- {
                  // On success, update the state using the command's predictable update method.
                  val next = cmd.update(stateWrapper.state)
                  Gen.some(
                    Gen.const(
                      StateWrapper(
                        next,
                        None
                      ) -> Step(cmd, next)
                    )
                  )
                }
              } yield res
            }
            .getOrElse(Gen.none)
        } yield step
      } else Gen.none
    }
  }.map(_._1).noShrink

  def allStepsSuccessful[R, S](steps: List[Step[R, S]]): ZIO[R, _, TestResult] =
    ZIO
      .foreach(steps)(s => s.command.executeAndCheck(s.state))
      .map(_.dropWhile(_.isSuccess).foldLeft(assertTrue(true))(_ && _))
}
